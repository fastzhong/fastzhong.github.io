+++
title = "淘宝服务端高并发分布式架构演进之路（转载）"
date = 2020-04-03T13:18:02+08:00
readingTime = true
categories = ["系统设计 & 架构"]
tags = []
toc = true
+++

架构就是些套路，开始先学，进级后可以自创。架构的核心是问题驱动，所以要明确要解决的问题。这篇着力点不在具体的技术实现和细节，而是对大型网站系统的总体架构演进和原则进行总结，很好、很到位，所采用的技术点都是经典套路，值得学习和推荐。

<!--more-->

🧾 **技术摘要**

```md
负载均衡技术：入口随流量升级

-   DNS 轮询
-   Nginx Keepalive
-   LVS
-   F5

中间件技术：

-   分布式事务
-   分布式缓存
-   ESB 服务总线/数据总线
-   Microservices & Service Mesh
-   容器化 & 动态服务管理

数据层技术：

-   数据库中间件
-   读写分离
-   拆库、拆表
-   NoSQL：document，search， graphic， key-value， big data
-   多活多机房多数据中心
```

---

[<i class="fas fa-external-link-alt"></i>&nbsp; 原文](https://cloud.tencent.com/developer/article/1447954)

## 概述

本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。

> 特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径

## 基本概念

在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：

-   <span class="kwd2">分布式</span> 系统中的多个模块在不同服务器上部署，即可称为分布式系统，如 Tomcat 和数据库分别部署在不同的服务器上，或两个相同功能的 Tomcat 分别部署在不同服务器上

-   <span class="kwd2">高可用</span> 系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性

-   <span class="kwd2">集群</span> 一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如 Zookeeper 中的 Master 和 Slave 分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性
-   <span class="kwd2">负载均衡</span> 请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的

-   <span class="kwd2">正向代理</span> 和 <span class="kwd2">反向代理</span> 系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。

## 架构演进

### 单机架构

![单机架构](/images/taobao/单机架构.png)

以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把 Tomcat 和数据库部署在同一台服务器上。浏览器往 www.taobao.com 发起请求时，首先经过 DNS 服务器（域名系统）把域名转换为实际 IP 地址 10.102.4.1，浏览器转而访问该 IP 对应的 Tomcat。

> 随着用户数的增长，Tomcat 和数据库之间竞争资源，单机性能不足以支撑业务。

### 第一次演进：Tomcat 与数据库分开部署

![Tomcat与数据库分开部署](/images/taobao/1.png)

Tomcat 和数据库分别独占服务器资源，显著提高两者各自性能。

> 随着用户数的增长，并发读写数据库成为瓶颈

### 第二次演进：引入本地缓存和分布式缓存

![Tomcat与数据库分开部署](/images/taobao/2.png)

在 Tomcat 同服务器上或同 JVM 中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的 html 页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用 memcached 作为本地缓存，使用 Redis 作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。

> 缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的 Tomcat 上，响应逐渐变慢

### 第三次演进：引入反向代理实现负载均衡

![Tomcat与数据库分开部署](/images/taobao/3.png)

在多台服务器上分别部署 Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个 Tomcat 中。此处假设 Tomcat 最多支持 100 个并发，Nginx 最多支持 50000 个并发，那么理论上 Nginx 把请求分发到 500 个 Tomcat 上，就能抗住 50000 个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持 http 协议，还会涉及 session 共享、文件上传下载的问题。

> 反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈

### 第四次演进：数据库读写分离

![Tomcat与数据库分开部署](/images/taobao/4.png)

把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：<span class="kwd">Mycat</span>，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库。MyCat 是从 Cobar 发展而来的，而 Cobar 是阿里开源的数据库中间件，后来停止开发。MyCat 是国内比较好的 MySql 开源数据库分库分表中间件。分库后会出现数据一致性的问题。那么对于这种情况，我们可以先考虑使用使用 MySQL 自带的 Master + Slave 的方式实现<span class="uline">主从复制</span>。

> 业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能

### 第五次演进：数据库按业务分库（垂直拆分）

![Tomcat与数据库分开部署](/images/taobao/5.png)

我们的网站演进到现在，交易、商品、用户的数据都还在同一个数据库中。尽管采取了增加缓存和读写分离的方式，但随着数据库的压力继续增加，数据库数据量的瓶颈越来越突出，此时，我们可以有<span class="kwd2">数据垂直拆分</span>和<span class="kwd2">水平拆分</span>两种选择。

垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中，结合现在的例子，就是把交易、商品、用户的数据分开。

优点：

-   解决了原来把所有业务放在一个数据库中的压力问题
-   可以根据业务的特点进行更多的优化

缺点：

-   需要维护多个数据库的状态一致性和数据同步。

问题：

-   需要考虑原来跨业务的事务
-   跨数据库的 Join

解决问题方案：

-   应该在应用层<span class="uline">尽量避免跨数据库的分布式事务</span>，如果非要跨数据库，尽量在代码中控制。
-   通过第三方中间件来解决，如上面提到的 MyCat，MyCat 提供了丰富的跨库 Join 方案，详情可参考 MyCat 官方文档。

> 随着用户数的增长，单机的写库会逐渐会达到性能瓶颈

### 第六次演进：把大表拆分为小表（水平拆分）

![Tomcat与数据库分开部署](/images/taobao/6.png)

数据水平拆分就是把同一个表中的数据拆分到两个甚至多个数据库中。产生数据水平拆分的原因是某个业务的数据量或者更新量到达了单个数据库的瓶颈，这时就可以把这个表拆分到两个或更多个数据库中。

优点：

-   如果能克服以上问题，那么我们将能够很好地对数据量及写入量增长的情况。

问题：

-   访问用户信息的应用系统需要解决 SQL 路由的问题，因为现在用户信息分在了两个数据库中，需要在进行数据操作时了解需要操作的数据在哪里。
-   主键的处理也变得不同，例如原来自增字段，现在不能简单地继续使用。
-   如果需要分页查询，那就更加麻烦。

解决问题方案：

-   我们还是可以通过可以解决第三方中间件，如 MyCat。MyCat 可以通过 SQL 解析模块对我们的 SQL 进行解析，再根据我们的配置，把请求转发到具体的某个数据库。我们可以通过 UUID 保证唯一或自定义 ID 方案来解决。
-   MyCat 也提供了丰富的分页查询方案，比如先从每个数据库做分页查询，再合并数据做一次分页查询等等。

比如针对评论数据，可按照商品 ID 进行 hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户 ID 或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。

这种做法显著的增加了数据库运维的难度，对 DBA 的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由 Mycat 实现，SQL 的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是 <span class="kwd">MPP</span>（大规模并行处理）架构的一类实现。

目前开源和商用都已经有不少 MPP 数据库，开源中比较流行的有 <span class="kwd">Greenplum</span>、<span class="kwd">TiDB</span>、<span class="kwd">Postgresql XC</span>、<span class="kwd">HAWQ</span> 等，商用的如南大通用的 GBase、睿帆科技的雪球 DB、华为的 LibrA 等等，不同的 MPP 数据库的侧重点也不一样，如 TiDB 更侧重于分布式 OLTP 场景，Greenplum 更侧重于分布式 OLAP 场景，这些 MPP 数据库基本都提供了类似 Postgresql、Oracle、MySQL 那样的 SQL 标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持 100 个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。

> 数据库和 Tomcat 都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的 Nginx 会成为瓶颈

### 第七次演进：使用 LVS 或 F5 来使多个 Nginx 负载均衡

![Tomcat与数据库分开部署](/images/taobao/7.png)

由于瓶颈在 Nginx，因此无法通过两层的 Nginx 来实现多个 Nginx 的负载均衡。图中的 <span class="kwd">LVS</span> 和 <span class="kwd">F5</span> 是工作在网络第四层的负载均衡解决方案，其中 LVS 是软件，运行在操作系统内核态，可对 TCP 请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于 Nginx，可假设单机的 LVS 可支持几十万个并发的请求转发；F5 是一种负载均衡硬件，与 LVS 提供的能力类似，性能比 LVS 更高，但价格昂贵。由于 LVS 是单机版的软件，若 LVS 所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用 keepalived 软件模拟出虚拟 IP，然后把虚拟 IP 绑定到多台 LVS 服务器上，浏览器访问虚拟 IP 时，会被路由器重定向到真实的 LVS 服务器，当主 LVS 服务器宕机时，keepalived 软件会自动更新路由器中的路由表，把虚拟 IP 重定向到另外一台正常的 LVS 服务器，从而达到 LVS 服务器高可用的效果。

此处需要注意的是，上图中从 Nginx 层到 Tomcat 层这样画并不代表全部 Nginx 都转发请求到全部的 Tomcat，在实际使用时，可能会是几个 Nginx 下面接一部分的 Tomcat，这些 Nginx 之间通过 <span class="kwd">keepalived</span> 实现高可用，其他的 Nginx 接另外的 Tomcat，这样可接入的 Tomcat 数量就能成倍的增加。

系统演变到这里，将会出现下面四个问题：

1. 用户的请求由谁来转发到到具体的应用服务器？（<span class="kwd2">负载均衡</span> ）
2. 有那些转发的算法和策略可以使用？（<span class="kwd2">集群调度转发算法</span>）
3. 应用服务器如何返回用户的请求？
4. 用户如果每次访问到的服务器不一样，那么如何维护 <span class="kwd2">Session 一致性</span> ？

针对以上问题，常用的解决方案如下：

#### 负载均衡

一般以下有 5 种解决方案：

-   <span class="kwd">HTTP 重定向</span>

    ```md
    HTTP 重定向就是应用层的请求转发。
    用户的请求其实已经到了 HTTP 重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群。
    ```

    优点：简单易用  
    缺点：性能较差

-   <span class="kwd">DNS 域名解析负载均衡</span>

    ```md
    DNS 域名解析负载均衡就是在用户请求 DNS 服务器，获取域名对应的 IP 地址时，DNS 服务器直接给出负载均衡后的服务器 IP。
    ```

    优点：交给 DNS，不用我们去维护负载均衡服务器  
    缺点：当一个应用服务器挂了，不能及时通知 DNS，而且 DNS 负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。

-   <span class="kwd">反向代理服务器</span>

    ```md
    在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。
    常用的 Apache，Nginx 都可以充当反向代理服务器。
    ```

    优点：部署简单  
    缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件。

-   <span class="kwd">IP 层负载均衡</span>

    ```md
    在请求到达负载均衡器后，负载均衡器通过修改请求的目的 IP 地址，从而实现请求的转发，做到负载均衡。
    ```

    优点：性能更好  
    缺点：负载均衡器的宽带成为瓶颈

-   <span class="kwd">数据链路层负载均衡</span>
    ```md
    在请求到达负载均衡器后，负载均衡器通过修改请求的 MAC 地址，从而做到负载均衡。  
    与 IP 负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。
    ```

#### 集群调度

-   <span class="kwd">轮询调度算法 rr</span>

    ```md
    顾名思义，轮询分发请求。
    ```

    优点：实现简单  
    缺点：不考虑每台服务器的处理能力

-   <span class="kwd">加权调度算法 wrr</span>

    ```md
    给每个服务器设置权值 Weight，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。
    ```

    优点：考虑了服务器处理能力的不同

-   <span class="kwd">原地址散列算法 sh</span>

    ```md
    提取用户 IP，根据散列函数得出一个 key，再根据静态映射表，查处对应的 value，即目标服务器 IP。
    过目标机器超负荷，则返回空。
    ```

    优点：实现同一个用户访问同一个服务器

-   <span class="kwd">目标地址散列算法 dh</span>

    ```md
    原理同上，只是现在提取的是目标地址的 IP 来做哈希。
    ```

    优点：实现同一个用户访问同一个服务器

-   <span class="kwd">最少连接算法 lc</span>

    ```md
    优先把请求转发给连接数少的服务器。
    ```

    优点：使得集群中各个服务器的负载更加均匀

-   <span class="kwd">加权最少连接算法 wcl</span>

    ```md
    在 lc 的基础上，为每台服务器加上权值。
    算法为：（活动连接数 \* 256 + 非活动连接数） ÷ 权重，计算出来的值小的服务器优先被选择。
    ```

    优点：可以根据服务器的能力分配请求

-   <span class="kwd">最短期望延迟算法 sed</span>

    ```md
    其实 sed 跟 wlc 类似，区别是不考虑非活动连接数。
    算法为：（活动连接数 +1 ) \* 256 ÷ 权重，同样计算出来的值小的服务器优先被选择。
    ```

-   <span class="kwd">永不排队算法 nq</span>

    ```md
    改进的 sed 算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为 0 的时候，那么假如有服务器连接数为 0，均衡器直接把请求转发给它，无需经过 sed 的计算。
    ```

-   <span class="kwd">基于局部性最少连接算法 LBLC</span>

    ```md
    负载均衡器根据请求的目的 IP 地址，找出该 IP 地址最近被使用的服务器，把请求转发之。
    若该服务器超载，最采用最少连接数算法。
    ```

-   <span class="kwd">带复制的基于局部性最少连接算法 LBLCR</span>

    ```md
    负载均衡器根据请求的目的 IP 地址，找出该 IP 地址最近使用的“服务器组”，
    注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。
    若该服务器超载，那么根据最少连接数算法，在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发。
    ```

#### 集群请求返回模式

-   <span class="kwd">NAT</span>

    ```md
    负载均衡器接收用户的请求，转发给具体服务器，服务器处理完请求返回给均衡器，均衡器再重新返回给用户。
    ```

-   <span class="kwd">DR</span>

    ```md
    负载均衡器接收用户的请求，转发给具体服务器，服务器出来玩请求后直接返回给用户。
    需要系统支持 IP Tunneling 协议，难以跨平台。
    ```

-   <span class="kwd">TUN</span>

    ```md
    同上，但无需 IP Tunneling 协议，跨平台性好，大部分系统都可以支持。
    ```

#### 集群 Session 一致性

-   <span class="kwd">Sticky Session</span>

    ```md
    Sticky Session 就是把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的 session 问题了，常见的算法有 ip_hash 算法，即上面提到的两种散列算法。
    ```

    优点：实现简单
    缺点：应用服务器重启则 session 消失

-   <span class="kwd">Session Replication

    ```md
    Session replication 就是在集群中复制 session，使得每个服务器都保存有全部用户的 session 数据。
    ```

    优点：减轻负载均衡服务器的压力，不需要要实现 ip_hasp 算法来转发请求
    缺点：复制时网络带宽开销大，访问量大的话 Session 占用内存大且浪费

-   Session 数据集中存储

    ```md
    Session 数据集中存储就是利用数据库来存储 session 数据，实现了 session 和应用服务器的解耦。
    ```

    优点：相比 Session replication 的方案，集群间对于宽带和内存的压力大幅减少
    缺点：需要维护存储 Session 的数据库

-   Cookie Base

    ```md
    Cookie base 就是把 Session 存在 Cookie 中，由浏览器来告诉应用服务器我的 session 是什么，同样实现了 session 和应用服务器的解耦。
    ```

    优点：实现简单，基本免维护
    缺点：cookie 长度限制，安全性低，带宽消耗

值得一提的是：

-   <span class="kwd">Nginx</span> 目前支持的负载均衡算法有 <span class="kwd">wrr</span>、<span class="kwd">sh（支持一致性哈希）</span>、<span class="kwd">fair（lc）</span>。但 Nginx 作为均衡器的话，还可以一同作为<span class="uline">静态资源服务器</span>。
-   <span class="kwd">Keepalived + ipvsadm</span> 比较强大，目前支持的算法有：<span class="kwd">rr</span>、<span class="kwd">wrr</span>、<span class="kwd">lc</span>、<span class="kwd">wlc</span>、<span class="kwd">lblc</span>、<span class="kwd">sh</span>、<span class="kwd">dh</span>
-   Keepalived 支持集群模式有：<span class="kwd">NAT</span>、<span class="kwd">DR</span>、<span class="kwd">TUN</span>
-   <span class="kwd">Nginx</span> 本身并没有提供 session 同步的解决方案，而 <span class="kwd">Apache</span> 则提供了 session 共享的支持。

> 由于 LVS 也是单机的，随着并发数增长到几十万时，LVS 服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同

### 第八次演进：通过 DNS 轮询实现机房间的负载均衡

![Tomcat与数据库分开部署](/images/taobao/8.png)

在 DNS 服务器中可配置一个域名对应多个 IP 地址，每个 IP 地址对应到不同的机房里的虚拟 IP。当用户访问 www.taobao.com 时，DNS 服务器会使用轮询策略或其他策略，来选择某个 IP 供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。

> 随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求

### 第九次演进：引入 NoSQL 数据库和搜索引擎等技术

![Tomcat与数据库分开部署](/images/taobao/9.png)

当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统 <span class="kwd">HDFS</span> 解决，对于 key value 类型的数据，可通过 <span class="kwd">HBase</span> 和 <span class="kwd">Redis</span> 等方案解决，对于全文检索场景，可通过搜索引擎如 <span class="kwd">ElasticSearch</span> 解决，对于多维分析场景，可通过 <span class="kwd">Kyli</span> 或 <span class="kwd">Druid</span> 等方案解决。

当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。

> 引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难

### 第十次演进：大应用拆分为小应用

![Tomcat与数据库分开部署](/images/taobao/10.png)

按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心 <span class="kwd">Apollo</span>、<span class="kwd">Nacos</span>、<span class="kwd">Zookeeper</span> 等来解决。

> 不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级

### 第十一次演进：复用的功能抽离成微服务

![Tomcat与数据库分开部署](/images/taobao/11.png)

如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过 HTTP、TCP 或 RPC 请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过 <span class="kwd">Dubbo</span>、<span class="kwd">SpringCloud</span> 等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。

> 不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱

### 第十二次演进：引入企业服务总线 ESB 屏蔽服务接口的访问差异

![Tomcat与数据库分开部署](/images/taobao/12.png)

通过 ESB 统一进行访问协议转换，应用统一通过 ESB 来访问后端服务，服务与服务之间也通过 ESB 来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的 SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而 SOA 架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA 架构中包含了微服务的思想。

> 业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难

### 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理

![Tomcat与数据库分开部署](/images/taobao/13.png)

目前最流行的容器化技术是 <span class="kwd">Docker</span>，最流行的容器管理服务是 <span class="kwd">Kubernetes</span> (K8S)，应用/服务可以打包为 Docker 镜像，通过 K8S 来动态分发和部署镜像。Docker 镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动 Docker 镜像就可以把服务起起来，使服务的部署和运维变得简单。

在大促的之前，可以在现有的机器集群上划分出服务器来启动 Docker 镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在 3.14 节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。

服务治理功能可以下降到容器底层实现，<span class="kwd">Service Mesh</span> 和 <span class="kwd">Data Mesh</span>的概念出现。

> 使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低

### 第十四次演进：以云平台承载系统

![Tomcat与数据库分开部署](/images/taobao/14.png)

系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合 Docker 和 K8S 来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。

所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如 CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如 Hadoop 技术栈，MPP 数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：

<span class="kwd2">IaaS</span>：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；  
<span class="kwd2">PaaS</span>：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；  
<span class="kwd2">SaaS</span>：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费
<span class="kwd2">CaaS/KaaS</span>：容器/Kubernetes 即服务

> 至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论

## 架构设计总结 💯

-   架构的调整是否必须按照上述演变路径进行？  
    不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。

-   对于将要实施的系统，架构应该设计到什么程度？  
    对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。

-   服务端架构和大数据架构有什么区别？  
    所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有 <span class="kwd">Flume</span>、<span class="kwd">Sqoop</span>、<span class="kwd">Kettle</span> 等，数据存储有分布式文件系统 <span class="kwd">HDFS</span>、<span class="kwd">FastDFS</span>，NoSQL 数据库 <span class="kwd">HBase</span>、<span class="kwd">MongoDB</span> 等，批流数据处理和分析有 <span class="kwd">Flink</span>、<span class="kwd">Spark</span> 技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。

-   有没有一些架构设计的原则？

    -   <span class="kwd2">N+1 设计</span>：系统中的每个组件都应做到没有单点故障；
    -   <span class="kwd2">回滚设计</span>：确保系统可以向前兼容，在系统升级时应能有办法回滚版本；
    -   <span class="kwd2">禁用设计</span>：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；
    -   <span class="kwd2">监控设计</span>：在设计阶段就要考虑监控的手段；
    -   <span class="kwd2">多活数据中心设计</span>：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；
    -   <span class="kwd2">采用成熟的技术</span>：刚开发的或开源的技术往往存在很多隐藏的 bug，出了问题没有商业支持可能会是一个灾难；
    -   <span class="kwd2">资源隔离设计</span>：应避免单一业务占用全部资源；
    -   <span class="kwd2">架构应能水平扩展</span>：系统只有做到能水平扩展，才能有效避免瓶颈问题；
    -   <span class="kwd2">非核心则购买</span>：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；
    -   <span class="kwd2">使用商用硬件</span>：商用硬件能有效降低硬件故障的机率；
    -   <span class="kwd2">快速迭代</span>：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；
    -   <span class="kwd2">无状态设计</span>：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。
